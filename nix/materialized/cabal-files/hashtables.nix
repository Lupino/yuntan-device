{ system
  , compiler
  , flags
  , pkgs
  , hsPkgs
  , pkgconfPkgs
  , errorHandler
  , config
  , ... }:
  ({
    flags = {
      unsafe-tricks = true;
      bounds-checking = false;
      debug = false;
      detailed-profiling = false;
      sse42 = false;
      portable = false;
      };
    package = {
      specVersion = "2.2";
      identifier = { name = "hashtables"; version = "1.3"; };
      license = "BSD-3-Clause";
      copyright = "(c) 2011-2014, Google, Inc., 2016-present contributors";
      maintainer = "greg@gregorycollins.net, mgoremeier@gmail.com, erikd@mega-nerd.com";
      author = "Gregory Collins";
      homepage = "http://github.com/gregorycollins/hashtables";
      url = "";
      synopsis = "Mutable hash tables in the ST monad";
      description = "This package provides a couple of different implementations of mutable hash\ntables in the ST monad, as well as a typeclass abstracting their common\noperations, and a set of wrappers to use the hash tables in the IO monad.\n\n/QUICK START/: documentation for the hash table operations is provided in the\n\"Data.HashTable.Class\" module, and the IO wrappers (which most users will\nprobably prefer) are located in the \"Data.HashTable.IO\" module.\n\nThis package currently contains three hash table implementations:\n\n1. \"Data.HashTable.ST.Cuckoo\" contains an implementation of \\\"cuckoo\nhashing\\\" as introduced by Pagh and Rodler in 2001 (see\n<http://en.wikipedia.org/wiki/Cuckoo_hashing>). Cuckoo hashing has\nworst-case /O(1)/ lookups and can reach a high \\\"load factor\\\", in which\nthe table can perform acceptably well even when approaching 90% full.\nRandomized testing shows this implementation of cuckoo hashing to be\nslightly faster on insert and slightly slower on lookup than\n\"Data.HashTable.ST.Basic\", while being more space efficient by about a\nhalf-word per key-value mapping. Cuckoo hashing, like the basic hash\ntable implementation using linear probing, can suffer from long delays\nwhen the table is resized.\n\n2. \"Data.HashTable.ST.Basic\" contains a basic open-addressing hash table\nusing linear probing as the collision strategy. On a pure speed basis it\nshould currently be the fastest available Haskell hash table\nimplementation for lookups, although it has a higher memory overhead\nthan the other tables and can suffer from long delays when the table is\nresized because all of the elements in the table need to be rehashed.\n\n3. \"Data.HashTable.ST.Linear\" contains a linear hash table (see\n<http://en.wikipedia.org/wiki/Linear_hashing>), which trades some insert\nand lookup performance for higher space efficiency and much shorter\ndelays when expanding the table. In most cases, benchmarks show this\ntable to be currently slightly faster than @Data.HashTable@ from the\nHaskell base library.\n\nIt is recommended to create a concrete type alias in your code when using this\npackage, i.e.:\n\n> import qualified Data.HashTable.IO as H\n>\n> type HashTable k v = H.BasicHashTable k v\n>\n> foo :: IO (HashTable Int Int)\n> foo = do\n>     ht <- H.new\n>     H.insert ht 1 1\n>     return ht\n\nFirstly, this makes it easy to switch to a different hash table implementation,\nand secondly, using a concrete type rather than leaving your functions abstract\nin the HashTable class should allow GHC to optimize away the typeclass\ndictionaries.\n\nThis package accepts a couple of different cabal flags:\n\n* @unsafe-tricks@, default /ON/. If this flag is enabled, we use some\nunsafe GHC-specific tricks to save indirections (namely @unsafeCoerce#@\nand @reallyUnsafePtrEquality#@. These techniques rely on assumptions\nabout the behaviour of the GHC runtime system and, although they've been\ntested and should be safe under normal conditions, are slightly\ndangerous. Caveat emptor. In particular, these techniques are\nincompatible with HPC code coverage reports.\n\n* @sse42@, default /OFF/. If this flag is enabled, we use some SSE 4.2\ninstructions (see <http://en.wikipedia.org/wiki/SSE4>, first available on\nIntel Core 2 processors) to speed up cache-line searches for cuckoo\nhashing.\n\n* @bounds-checking@, default /OFF/. If this flag is enabled, array accesses\nare bounds-checked.\n\n* @debug@, default /OFF/. If turned on, we'll rudely spew debug output to\nstdout.\n\n* @portable@, default /OFF/. If this flag is enabled, we use only pure\nHaskell code and try not to use unportable GHC extensions. Turning this\nflag on forces @unsafe-tricks@ and @sse42@ /OFF/.\n\nPlease send bug reports to\n<https://github.com/gregorycollins/hashtables/issues>.";
      buildType = "Simple";
      };
    components = {
      "library" = {
        depends = [
          (hsPkgs."base" or (errorHandler.buildDepError "base"))
          (hsPkgs."hashable" or (errorHandler.buildDepError "hashable"))
          (hsPkgs."primitive" or (errorHandler.buildDepError "primitive"))
          (hsPkgs."vector" or (errorHandler.buildDepError "vector"))
          ] ++ (pkgs.lib).optional (!flags.portable && flags.unsafe-tricks && (compiler.isGhc && true)) (hsPkgs."ghc-prim" or (errorHandler.buildDepError "ghc-prim"));
        buildable = true;
        };
      tests = {
        "testsuite" = {
          depends = [
            (hsPkgs."base" or (errorHandler.buildDepError "base"))
            (hsPkgs."hashable" or (errorHandler.buildDepError "hashable"))
            (hsPkgs."mwc-random" or (errorHandler.buildDepError "mwc-random"))
            (hsPkgs."primitive" or (errorHandler.buildDepError "primitive"))
            (hsPkgs."QuickCheck" or (errorHandler.buildDepError "QuickCheck"))
            (hsPkgs."HUnit" or (errorHandler.buildDepError "HUnit"))
            (hsPkgs."test-framework" or (errorHandler.buildDepError "test-framework"))
            (hsPkgs."test-framework-quickcheck2" or (errorHandler.buildDepError "test-framework-quickcheck2"))
            (hsPkgs."test-framework-hunit" or (errorHandler.buildDepError "test-framework-hunit"))
            (hsPkgs."vector" or (errorHandler.buildDepError "vector"))
            ] ++ (pkgs.lib).optional (!flags.portable && flags.unsafe-tricks && (compiler.isGhc && true)) (hsPkgs."ghc-prim" or (errorHandler.buildDepError "ghc-prim"));
          buildable = true;
          };
        };
      };
    } // {
    src = (pkgs.lib).mkDefault (pkgs.fetchurl {
      url = "http://hackage.haskell.org/package/hashtables-1.3.tar.gz";
      sha256 = "af785a6d13842ebbd804b0ec174dd957a2591b224434e3ce883f537321f90dd3";
      });
    }) // {
    package-description-override = "Cabal-Version: 2.2\nName:                hashtables\nVersion:             1.3\nSynopsis:            Mutable hash tables in the ST monad\nHomepage:            http://github.com/gregorycollins/hashtables\nLicense:             BSD-3-Clause\nLicense-file:        LICENSE\nAuthor:              Gregory Collins\nMaintainer:          greg@gregorycollins.net, mgoremeier@gmail.com, erikd@mega-nerd.com\nCopyright:           (c) 2011-2014, Google, Inc., 2016-present contributors\nCategory:            Data\nBuild-type:          Simple\n\n\ntested-with:\n  GHC == 7.8.4\n  GHC == 7.10.3\n  GHC == 8.0.2\n  GHC == 8.2.2\n  GHC == 8.4.4\n  GHC == 8.6.5\n  GHC == 8.8.4\n  GHC == 8.10.7\n  GHC == 9.0.1\n  GHC == 9.2.1\n\nDescription:\n  This package provides a couple of different implementations of mutable hash\n  tables in the ST monad, as well as a typeclass abstracting their common\n  operations, and a set of wrappers to use the hash tables in the IO monad.\n  .\n  /QUICK START/: documentation for the hash table operations is provided in the\n  \"Data.HashTable.Class\" module, and the IO wrappers (which most users will\n  probably prefer) are located in the \"Data.HashTable.IO\" module.\n  .\n  This package currently contains three hash table implementations:\n  .\n    1. \"Data.HashTable.ST.Cuckoo\" contains an implementation of \\\"cuckoo\n       hashing\\\" as introduced by Pagh and Rodler in 2001 (see\n       <http://en.wikipedia.org/wiki/Cuckoo_hashing>). Cuckoo hashing has\n       worst-case /O(1)/ lookups and can reach a high \\\"load factor\\\", in which\n       the table can perform acceptably well even when approaching 90% full.\n       Randomized testing shows this implementation of cuckoo hashing to be\n       slightly faster on insert and slightly slower on lookup than\n       \"Data.HashTable.ST.Basic\", while being more space efficient by about a\n       half-word per key-value mapping. Cuckoo hashing, like the basic hash\n       table implementation using linear probing, can suffer from long delays\n       when the table is resized.\n  .\n    2. \"Data.HashTable.ST.Basic\" contains a basic open-addressing hash table\n       using linear probing as the collision strategy. On a pure speed basis it\n       should currently be the fastest available Haskell hash table\n       implementation for lookups, although it has a higher memory overhead\n       than the other tables and can suffer from long delays when the table is\n       resized because all of the elements in the table need to be rehashed.\n  .\n    3. \"Data.HashTable.ST.Linear\" contains a linear hash table (see\n       <http://en.wikipedia.org/wiki/Linear_hashing>), which trades some insert\n       and lookup performance for higher space efficiency and much shorter\n       delays when expanding the table. In most cases, benchmarks show this\n       table to be currently slightly faster than @Data.HashTable@ from the\n       Haskell base library.\n  .\n  It is recommended to create a concrete type alias in your code when using this\n  package, i.e.:\n  .\n  > import qualified Data.HashTable.IO as H\n  >\n  > type HashTable k v = H.BasicHashTable k v\n  >\n  > foo :: IO (HashTable Int Int)\n  > foo = do\n  >     ht <- H.new\n  >     H.insert ht 1 1\n  >     return ht\n  .\n  Firstly, this makes it easy to switch to a different hash table implementation,\n  and secondly, using a concrete type rather than leaving your functions abstract\n  in the HashTable class should allow GHC to optimize away the typeclass\n  dictionaries.\n  .\n  This package accepts a couple of different cabal flags:\n  .\n    * @unsafe-tricks@, default /ON/. If this flag is enabled, we use some\n      unsafe GHC-specific tricks to save indirections (namely @unsafeCoerce#@\n      and @reallyUnsafePtrEquality#@. These techniques rely on assumptions\n      about the behaviour of the GHC runtime system and, although they've been\n      tested and should be safe under normal conditions, are slightly\n      dangerous. Caveat emptor. In particular, these techniques are\n      incompatible with HPC code coverage reports.\n  .\n    * @sse42@, default /OFF/. If this flag is enabled, we use some SSE 4.2\n      instructions (see <http://en.wikipedia.org/wiki/SSE4>, first available on\n      Intel Core 2 processors) to speed up cache-line searches for cuckoo\n      hashing.\n  .\n    * @bounds-checking@, default /OFF/. If this flag is enabled, array accesses\n      are bounds-checked.\n  .\n    * @debug@, default /OFF/. If turned on, we'll rudely spew debug output to\n      stdout.\n  .\n    * @portable@, default /OFF/. If this flag is enabled, we use only pure\n      Haskell code and try not to use unportable GHC extensions. Turning this\n      flag on forces @unsafe-tricks@ and @sse42@ /OFF/.\n  .\n  Please send bug reports to\n  <https://github.com/gregorycollins/hashtables/issues>.\n\nExtra-Source-Files:\n  README.md,\n  cabal.project,\n  haddock.sh,\n  benchmark/hashtable-benchmark.cabal,\n  benchmark/LICENSE,\n  benchmark/src/Criterion/Collection/Internal/Types.hs,\n  benchmark/src/Criterion/Collection/Chart.hs,\n  benchmark/src/Criterion/Collection/Main.hs,\n  benchmark/src/Criterion/Collection/Types.hs,\n  benchmark/src/Criterion/Collection/Sample.hs,\n  benchmark/src/Main.hs,\n  benchmark/src/Data/Vector/Algorithms/Shuffle.hs,\n  benchmark/src/Data/Benchmarks/UnorderedCollections/Distributions.hs,\n  benchmark/src/Data/Benchmarks/UnorderedCollections/Types.hs,\n  cbits/Makefile,\n  cbits/check.c,\n  cbits/defs.h,\n  cbits/sse-42-check.c,\n  changelog.md,\n  test/compute-overhead/ComputeOverhead.hs,\n  test/hashtables-test.cabal,\n  test/suite/Data/HashTable/Test/Common.hs,\n  test/suite/TestSuite.hs\n\n\n------------------------------------------------------------------------------\nFlag unsafe-tricks\n  Description: turn on unsafe GHC tricks\n  Default:   True\n\nFlag bounds-checking\n  Description: if on, use bounds-checking array accesses\n  Default: False\n\nFlag debug\n  Description: if on, spew debugging output to stdout\n  Default: False\n  Manual: True\n\nFlag detailed-profiling\n  Description: add detailed profiling information to profiled build-depends\n  Default: False\n  Manual: True\n\nFlag sse42\n  Description: if on, use SSE 4.2 extensions to search cache lines very\n               efficiently. The portable flag forces this off.\n  Default: False\n\nFlag portable\n  Description: if on, use only pure Haskell code and no GHC extensions.\n  Default: False\n\n\nLibrary\n  Default-Language: Haskell2010\n  hs-source-dirs:    src\n\n  if flag(sse42) && !flag(portable)\n    cc-options:  -DUSE_SSE_4_2 -msse4.2\n    cpp-options: -DUSE_SSE_4_2\n    C-sources:   cbits/sse-42.c\n\n  if !flag(portable) && !flag(sse42)\n    C-sources:       cbits/default.c\n\n  if !flag(portable)\n    C-sources:       cbits/common.c\n\n  Exposed-modules:   Data.HashTable.Class,\n                     Data.HashTable.IO,\n                     Data.HashTable.ST.Basic,\n                     Data.HashTable.ST.Cuckoo,\n                     Data.HashTable.ST.Linear\n\n  Other-modules:     Data.HashTable.Internal.Array,\n                     Data.HashTable.Internal.IntArray,\n                     Data.HashTable.Internal.CacheLine,\n                     Data.HashTable.Internal.CheapPseudoRandomBitStream,\n                     Data.HashTable.Internal.UnsafeTricks,\n                     Data.HashTable.Internal.Utils,\n                     Data.HashTable.Internal.Linear.Bucket\n\n  Build-depends:     base      >= 4.7 && <5,\n                     hashable  >= 1.4 && < 1.5,\n                     primitive,\n                     vector    >= 0.7 && <0.13\n\n  if flag(portable)\n    cpp-options: -DNO_C_SEARCH -DPORTABLE\n\n  if !flag(portable) && flag(unsafe-tricks) && impl(ghc)\n    build-depends: ghc-prim\n    cpp-options: -DUNSAFETRICKS\n\n  if flag(debug)\n    cpp-options: -DDEBUG\n\n  if flag(bounds-checking)\n    cpp-options: -DBOUNDS_CHECKING\n\n  if flag(detailed-profiling)\n    if impl(ghc >= 7.4.1)\n     ghc-prof-options: -fprof-auto\n    if impl(ghc < 7.4.1)\n     ghc-prof-options: -auto-all\n\n  if impl(ghc >= 6.12.0)\n    ghc-options: -Wall -fwarn-tabs -funbox-strict-fields\n                 -fno-warn-unused-do-bind\n  else\n    ghc-options: -Wall -fwarn-tabs -funbox-strict-fields\n\ntest-suite testsuite\n  Default-Language: Haskell2010\n  hs-source-dirs:    src test/suite\n  main-is:           TestSuite.hs\n  type: exitcode-stdio-1.0\n\n  other-modules:\n        Data.HashTable.Class\n        Data.HashTable.IO\n        Data.HashTable.Internal.Array\n        Data.HashTable.Internal.CacheLine\n        Data.HashTable.Internal.CheapPseudoRandomBitStream\n        Data.HashTable.Internal.IntArray\n        Data.HashTable.Internal.Linear.Bucket\n        Data.HashTable.Internal.UnsafeTricks\n        Data.HashTable.Internal.Utils\n        Data.HashTable.ST.Basic\n        Data.HashTable.ST.Cuckoo\n        Data.HashTable.ST.Linear\n        Data.HashTable.Test.Common\n\n  if flag(sse42) && !flag(portable)\n    cc-options:  -DUSE_SSE_4_2 -msse4.2\n    cpp-options: -DUSE_SSE_4_2\n    C-sources:   cbits/sse-42.c\n\n  if !flag(portable) && !flag(sse42)\n    C-sources:       cbits/default.c\n\n  if !flag(portable)\n    C-sources:       cbits/common.c\n\n  if flag(detailed-profiling)\n    ghc-prof-options:  -auto-all\n\n  if flag(portable)\n    cpp-options: -DNO_C_SEARCH -DPORTABLE\n\n  if !flag(portable) && flag(unsafe-tricks) && impl(ghc)\n    cpp-options: -DUNSAFETRICKS\n    build-depends: ghc-prim\n\n  if flag(debug)\n    cpp-options: -DDEBUG\n\n  if flag(bounds-checking)\n    cpp-options: -DBOUNDS_CHECKING\n\n  Build-depends:     base                       >= 4     && <5,\n                     hashable                   >= 1.4 && < 1.5,\n                     mwc-random                 >= 0.8   && <0.16,\n                     primitive,\n                     QuickCheck                 >= 2.3.0.2,\n                     HUnit                      >= 1.2   && <2,\n                     test-framework             >= 0.3.1 && <0.9,\n                     test-framework-quickcheck2 >= 0.2.6 && <0.4,\n                     test-framework-hunit       >= 0.2.6 && <3,\n                     vector                     >= 0.7\n\n  cpp-options: -DTESTSUITE\n\n  if impl(ghc >= 7)\n    ghc-options: -rtsopts\n\n  if impl(ghc >= 6.12.0)\n    ghc-options: -Wall -fwarn-tabs -funbox-strict-fields\n                 -fno-warn-unused-do-bind -threaded\n  else\n    ghc-options: -Wall -fwarn-tabs -funbox-strict-fields -threaded\n\n\n\nsource-repository head\n  type:     git\n  location: https://github.com/gregorycollins/hashtables.git\n";
    }